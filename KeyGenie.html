<!DOCTYPE html>
<html lang="en">
    <head>

        <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-P372MJFP');</script>
    <!-- End Google Tag Manager -->
        
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="KeyGenie is a powerful AI assistant designed to seamlessly integrate into your workflow, providing real-time AI assistance directly from your keyboard.">
        <meta name="keywords" content="KeyGenie, JJcoded, AI assistant, real-time AI, Python, GPT-4, AI integration, productivity">
        <meta name="robots" content="index, follow">
        <meta name="author" content="JJcoded">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism.css" rel="stylesheet" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.js"></script>
        <link rel="canonical" href="https://www.jjcoded.com/KeyGenie.html">
        <link rel="icon" href="images/favicon.png" type="image/png">
        <title>KeyGenie - JJcoded</title>
    
        <!-- Open Graph Meta Tags for Social Sharing -->
        <meta property="og:title" content="KeyGenie - JJcoded">
        <meta property="og:description" content="A productivity-enhancing AI assistant that brings the power of AI directly to your fingertips.">
        <meta property="og:image" content="https://www.jjcoded.com/images/write.png">
        <meta property="og:url" content="https://www.jjcoded.com/KeyGenie.html">
        <meta property="og:type" content="website">
    
        <!-- Twitter Card Meta Tags -->
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:title" content="KeyGenie - JJcoded">
        <meta name="twitter:description" content="Leverage AI in real-time with KeyGenie, integrated right into your keyboard.">
        <meta name="twitter:image" content="https://www.jjcoded.com/images/write.png">
    
        <!-- JSON-LD Schema Markup for Rich Snippets -->
        <script type="application/ld+json">
        {
          "@context": "https://schema.org",
          "@type": "SoftwareApplication",
          "name": "KeyGenie",
          "operatingSystem": "Windows",
          "applicationCategory": "Productivity",
          "offers": {
            "@type": "Offer",
            "price": "0.00",
            "priceCurrency": "AUD"
          },
          "description": "An AI assistant that integrates seamlessly into your workflow, providing real-time AI assistance from your keyboard.",
          "url": "https://www.jjcoded.com/KeyGenie.html",
          "image": "https://www.jjcoded.com/images/write.png",
          "softwareVersion": "1.0",
          "author": {
            "@type": "Organization",
            "name": "JJcoded"
          }
        }
        </script>
    
        <!-- Stylesheets -->
        <link rel="stylesheet" href="style-projects.css"> <!-- Project-specific CSS -->
    </head>
    
<body>

    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-P372MJFP"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
        
    <header>
        <h1>KeyGenie</h1>
        <nav>
            <a href="index.html" class="nav-link">Back to Projects</a>
        </nav>
    </header>

    <section class="project-detail">
        <h2>KeyGenie</h2>
        <p><em>A productivity-enhancing AI assistant that brings the power of AI directly to your fingertips.</em></p>
        <p>KeyGenie is a powerful AI assistant designed to seamlessly integrate into your existing workflow. By leveraging OpenAI's advanced language models, including GPT-4, KeyGenie provides real-time AI assistance directly from your keyboard, without interrupting your tasks.</p>
    
        <div class="content-container">
            <!-- Left Column: Source Code Block with Tabs -->
            <div class="code-container">
                <div class="code-header">
                    <div class="tab-bar">
                        <!-- textures/ folder -->
                        <div class="folder-group">
                            <div class="folder-wrapper">
                                <button class="folder-button" onclick="toggleFolder('textures-folder')">brain/</button>
                                <div id="textures-folder" class="file-tabs" style="display: none;">
                                    <button class="tab-button" onclick="showCode('setup.py')">setup.py</button>
                                    <button class="tab-button" onclick="showCode('backgroundai.py')">backgroundai.py</button>                                        <button class="tab-button" onclick="showCode('menu.py')">menu.py</button>
                                    <button class="tab-button" onclick="showCode('write.png')">write.png</button>
                                </div>
                            </div>
                        </div>
                        <!-- Python Files in the root -->
                        <button class="tab-button" onclick="showCode('RUN.py')">RUN.py</button>
                        <button class="tab-button" onclick="showCode('instructions.txt')">instructions.txt</button>
                    </div>
                </div>
                <!-- Code blocks or image display -->
                <div class="code-display">
                    <pre class="line-numbers"><code id="code-block" class="language-python"></code></pre>
                </div>
                <button class="copy-code-btn" id="copy-code-btn" aria-label="Copy Code">
                    <i class="fas fa-copy"></i>
                    <span class="tooltip-text">Copy Code</span>
                </button>
            </div>

                <!-- Right Column: Carousel for Images/Videos -->
                <div class="carousel-container">
                    <div class="carousel">
                        <div class="slides">
                            <img src="images/write.png" class="carousel-item" alt="Screenshot 1" style="display: block;">
                            <img src="images/KeyGenieSS.png" class="carousel-item" alt="Screenshot 2" style="display: block;">
                        </div>
                        <button class="carousel-prev" onclick="plusSlides(-1)">&#10094;</button>
                        <button class="carousel-next" onclick="plusSlides(1)">&#10095;</button>
                    </div>
                </div>
            </div>

        <div class="instructions">
            <h2>Installation Instructions</h2>
            <ol>
                <li>Download the KeyGenie program using the link below.</li>
                <li>Extract the contents of the ZIP file to a folder on your computer.</li>
                <li>Navigate to the extracted folder and locate <strong>run.py</strong>.</li>
                <li>Double-click <strong>run.py</strong> to start the program. If you do not have Python installed, follow the on-screen prompts to install it.</li>
                <li>After Python and the necessary modules are installed, the KeyGenie system tray icon will appear.</li>
                <li>Right-click the icon in the system tray and open the settings to enter your OpenAI API key and customize your experience.</li>
            </ol>
            <div class="download-links">
                <a href="https://github.com/DJJJNabba/KeyGenie/archive/refs/heads/main.zip" download>Download KeyGenie &nbsp;<i class="fa-solid fa-download"></i></a>
            </div>
        </div>
      

        <!-- New sections start here -->
        <section>
            <h2 id="keygenie">KeyGenie</h2>
<p><img src="images/write.png" alt="KeyGenie Logo" width="200"/></p>
<p><a href="https://github.com/DJJJNabba/KeyGenie/blob/main/LICENSE"><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="License"></a></p>
<hr>
<div id="table-of-contents-wrapper">
    <h2 id="table-of-contents">ðŸ“‘ Table of Contents</h2>
    <ul>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#features">Features</a></li>
        <li>
            <a href="#installation">Installation</a>
            <ul>
                <li><a href="#prerequisites">Prerequisites</a></li>
                <li><a href="#first-time-setup">First-Time Setup</a></li>
            </ul>
        </li>
        <li>
            <a href="#usage">Usage</a>
            <ul>
                <li><a href="#activating-keygenie">Activating KeyGenie</a></li>
                <li><a href="#keybinds">Keybinds</a></li>
                <li><a href="#customizing-settings">Customizing Settings</a></li>
            </ul>
        </li>
        <li>
            <a href="#advanced-configuration">Advanced Configuration</a>
            <ul>
                <li><a href="#custom-instructions">Custom Instructions</a></li>
                <li><a href="#model-selection">Model Selection</a></li>
                <li><a href="#typing-speed">Typing Speed</a></li>
                <li><a href="#text-to-speech-tts">Text-to-Speech (TTS)</a></li>
                <li><a href="#auto-start-on-system-boot">Auto-Start on System Boot</a></li>
            </ul>
        </li>
        <li>
            <a href="#detailed-features">Detailed Features</a>
            <ul>
                <li><a href="#streamlined-workflow-integration">Streamlined Workflow Integration</a></li>
                <li><a href="#customizable-and-flexible">Customizable and Flexible</a></li>
                <li><a href="#supports-long-form-content-generation">Supports Long-Form Content Generation</a></li>
                <li><a href="#lightweight-and-non-intrusive">Lightweight and Non-Intrusive</a></li>
            </ul>
        </li>
        <li>
            <a href="#use-cases">Use Cases</a>
            <ul>
                <li><a href="#creative-writing-and-content-generation">Creative Writing and Content Generation</a></li>
                <li><a href="#productivity-enhancement">Productivity Enhancement</a></li>
                <li><a href="#coding-assistance">Coding Assistance</a></li>
                <li><a href="#accessibility-support">Accessibility Support</a></li>
            </ul>
        </li>
        <li><a href="#folder-structure">Folder Structure</a></li>
        <li>
            <a href="#detailed-script-descriptions">Detailed Script Descriptions</a>
            <ul>
                <li><a href="#runpy">run.py</a></li>
                <li><a href="#backgroundaipy">backgroundai.py</a></li>
                <li><a href="#menupy">menu.py</a></li>
                <li><a href="#setuppy">setup.py</a></li>
            </ul>
        </li>
        <li><a href="#troubleshooting">Troubleshooting</a></li>
        <li><a href="#known-issues">Known Issues</a></li>
        <li><a href="#faqs">FAQs</a></li>
        <li><a href="#contributing">Contributing</a></li>
        <li><a href="#license">License</a></li>
        <li><a href="#acknowledgments">Acknowledgments</a></li>
        <li><a href="#contact">Contact</a></li>
    </ul>
</div>
<hr>

<h2 id="introduction">Introduction</h2>
<p><strong>KeyGenie</strong> is a powerful AI assistant designed to seamlessly integrate into your existing workflow. By leveraging OpenAI&#39;s advanced language models, including GPT-4, KeyGenie provides real-time AI assistance directly from your keyboard, without interrupting your tasks.</p>
<hr>
<h2 id="features">Features</h2>
<ul>
<li><strong>Real-Time AI Responses:</strong> Generate instant responses to any text prompt using OpenAIâ€™s models.</li>
<li><strong>Text-to-Speech (TTS):</strong> Listen to AI-generated responses with customizable speech settings.</li>
<li><strong>Customizable Keybinds:</strong> Set hotkeys to activate AI interactions without leaving your current application.</li>
<li><strong>Auto-Typing:</strong> Automatically type out AI responses at a customizable speed.</li>
<li><strong>Comprehensive Settings:</strong> Adjust temperature, max tokens, response speed, and more.</li>
<li><strong>System Tray Integration:</strong> Runs quietly in the background with easy access from the system tray.</li>
<li><strong>Effortless Setup:</strong> Automatic installation of dependencies for both technical and non-technical users.</li>
</ul>
<hr>
<h2 id="installation">Installation</h2>
<h3 id="prerequisites">Prerequisites</h3>
<ul>
<li><strong>Operating System:</strong> Windows</li>
<li><strong>Python 3:</strong> Ensure that Python 3 is installed and added to your system&#39;s PATH.</li>
</ul>
<p>To check if Python is installed:</p>
<pre><code class="lang-bash"><span class="hljs-keyword">python</span> --<span class="hljs-keyword">version</span>
</code></pre>
<p>If Python is not installed, download it from <a href="https://www.python.org/downloads/"target=â€_blankâ€>Python&#39;s official website</a>.</p>
<h3 id="first-time-setup">First-Time Setup</h3>
<ol>
<li><p><strong>Clone or Download the Repository:</strong></p>
<ul>
<li><p><strong>Clone via Git:</strong></p>
<pre><code class="lang-bash">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/yourusername/KeyGenie.git
</code></pre>
</li>
<li><p><strong>Download ZIP:</strong></p>
<ul>
<li>Click on the <strong>Code</strong> button on the GitHub repository page.</li>
<li>Select <strong>Download ZIP</strong>.</li>
<li>Extract the ZIP file to your desired location.</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Navigate to the Project Directory:</strong></p>
<pre><code class="lang-bash"><span class="hljs-built_in">cd</span> KeyGenie
</code></pre>
</li>
<li><p><strong>Run the Application:</strong></p>
<ul>
<li><strong>Option 1:</strong> Double-click <code>run.py</code>.</li>
<li><p><strong>Option 2:</strong> Run from the command line:</p>
<pre><code class="lang-bash">python <span class="hljs-keyword">run</span>.<span class="bash">py</span>
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Automatic Dependency Installation:</strong></p>
<ul>
<li>On the first run, KeyGenie will automatically install all necessary Python modules.</li>
<li>A file named <code>first_run.txt</code> will be created inside the <code>brain</code> folder after setup is complete.</li>
</ul>
</li>
<li><p><strong>Provide Your OpenAI API Key:</strong></p>
<ul>
<li>After running the application, find the KeyGenie icon in your system tray (near the clock).</li>
<li>Right-click the icon and select <strong>Open Settings</strong>.</li>
<li>Enter your OpenAI API key in the <strong>API Key</strong> field.</li>
<li>Click <strong>Save API Key</strong>.</li>
</ul>
<blockquote>
<p><strong>Note:</strong> You need a valid OpenAI API key to use this application. Sign up at <a href="https://platform.openai.com/signup"target=â€_blankâ€>OpenAI&#39;s website</a> if you don&#39;t have one.</p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="usage">Usage</h2>
<h3 id="activating-keygenie">Activating KeyGenie</h3>
<ul>
<li><p><strong>Prompt Mode:</strong></p>
<ul>
<li>Press the <strong>Prompt Keybind</strong> (default is <code>Right Shift</code>) to start capturing your input.</li>
<li>Type your prompt, and press the keybind again to stop capturing.</li>
<li>The AI will process your input and type out the response automatically.</li>
</ul>
</li>
<li><p><strong>Completion Mode:</strong></p>
<ul>
<li>Press the <strong>Completion Keybind</strong> (default is <code>Right Ctrl</code>) to start capturing text to be completed.</li>
<li>Type the text you want the AI to continue, and press the keybind again to stop capturing.</li>
<li>The AI will generate a continuation of your text.</li>
</ul>
</li>
<li><p><strong>Stopping the AI Typing or TTS:</strong></p>
<ul>
<li>Press any key on your keyboard to stop the AI from typing or speaking.</li>
</ul>
</li>
</ul>
<h3 id="keybinds">Keybinds</h3>
<ul>
<li><p><strong>Default Keybinds:</strong></p>
<ul>
<li><strong>Prompt Keybind:</strong> <code>Right Shift</code></li>
<li><strong>Completion Keybind:</strong> <code>Right Ctrl</code></li>
</ul>
</li>
<li><p><strong>Customizing Keybinds:</strong></p>
<ul>
<li>Open the <strong>Settings</strong> window from the system tray icon.</li>
<li>Navigate to the <strong>Keybinds</strong> section.</li>
<li>Click on <strong>Set</strong> next to the keybind you wish to change.</li>
<li>Press the new key you want to assign.</li>
</ul>
</li>
</ul>
<h3 id="customizing-settings">Customizing Settings</h3>
<ul>
<li><p><strong>Model Selection:</strong></p>
<ul>
<li>Choose from various OpenAI models, including GPT-4 and GPT-3.5-turbo.</li>
</ul>
</li>
<li><p><strong>Custom Instructions:</strong></p>
<ul>
<li>Add any custom instructions for the AI in the provided text area in the settings.</li>
</ul>
</li>
<li><p><strong>Additional Settings:</strong></p>
<ul>
<li><strong>Temperature:</strong> Controls the randomness of the AI&#39;s responses.</li>
<li><strong>Max Tokens:</strong> Limits the length of the AI&#39;s responses.</li>
<li><strong>Auto-Type:</strong> Enable or disable automatic typing of AI responses.</li>
<li><strong>Typing Speed:</strong> Adjust how fast the AI types back.</li>
<li><strong>Letter by Letter Typing:</strong> Choose whether the AI types letter by letter or in chunks.</li>
<li><strong>Play TTS:</strong> Enable text-to-speech to have the AI speak responses.</li>
<li><strong>TTS Rate:</strong> Adjust the speaking rate of the AI.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="advanced-configuration">Advanced Configuration</h2>
<h3 id="custom-instructions">Custom Instructions</h3>
<ul>
<li>Open the <strong>Settings</strong> window.</li>
<li>Navigate to <strong>Custom Instructions</strong>.</li>
<li>Enter your instructions in the text area.</li>
<li>Click <strong>Save Instructions</strong>.</li>
<li>These instructions will guide the AI&#39;s behavior across all interactions.</li>
</ul>
<h3 id="model-selection">Model Selection</h3>
<ul>
<li>Choose from a list of available OpenAI models.</li>
<li>Models include:<ul>
<li><strong>GPT-4</strong></li>
<li><strong>GPT-3.5-Turbo</strong></li>
<li><strong>GPT-3.5-Turbo-16k</strong></li>
<li>And more.</li>
</ul>
</li>
<li>Select the model that best fits your needs from the <strong>Model Selection</strong> dropdown in <strong>Settings</strong>.</li>
</ul>
<h3 id="typing-speed">Typing Speed</h3>
<ul>
<li>Adjust how fast the AI types back.</li>
<li>In <strong>Settings</strong>, adjust the <strong>Typing Speed</strong> slider.</li>
<li><strong>Letter by Letter Typing:</strong> Enable for a natural typing effect; disable for faster chunk typing.</li>
</ul>
<h3 id="text-to-speech-tts-">Text-to-Speech (TTS)</h3>
<ul>
<li>Enable TTS to have the AI&#39;s responses read aloud.</li>
<li>Adjust the <strong>TTS Rate</strong> to control speech speed.</li>
<li>Useful for multitasking or accessibility purposes.</li>
</ul>
<h3 id="auto-start-on-system-boot">Auto-Start on System Boot</h3>
<ul>
<li><strong>Enable Startup:</strong><ul>
<li>In <strong>Settings</strong>, click <strong>Enable from Startup</strong>.</li>
<li>This will create a shortcut in your startup folder.</li>
</ul>
</li>
<li><strong>Disable Startup:</strong><ul>
<li>Click <strong>Disable from Startup</strong> to remove the startup shortcut.</li>
</ul>
</li>
<li>Ensures KeyGenie runs automatically when you start your computer.</li>
</ul>
<hr>
<h2 id="detailed-features">Detailed Features</h2>
<h3 id="streamlined-workflow-integration">Streamlined Workflow Integration</h3>
<p>KeyGenie integrates into your existing workflow without interrupting your tasks. It operates in the background and can be summoned with simple key combinations, allowing you to maintain focus while getting AI assistance as needed.</p>
<h3 id="customizable-and-flexible">Customizable and Flexible</h3>
<p>Tailored to suit your preferences, KeyGenie offers a fully customizable experience. With adjustable keybinds, typing speed, AI model selection, and temperature settings, you have full control over how the AI behaves, ensuring it complements your working style.</p>
<h3 id="supports-long-form-content-generation">Supports Long-Form Content Generation</h3>
<p>Whether you&#39;re drafting emails, writing essays, or generating code, KeyGenie is capable of handling long-form content. It offers the ability to start and continue writing, providing suggestions or completing text seamlessly as you type.</p>
<h3 id="lightweight-and-non-intrusive">Lightweight and Non-Intrusive</h3>
<p>With its discreet system tray operation, KeyGenie stays out of your way until you need it. Unlike traditional AI tools that require you to switch to a separate interface or window, this tool works directly in any text field you&#39;re using.</p>
<hr>
<h2 id="use-cases">Use Cases</h2>
<h3 id="creative-writing-and-content-generation">Creative Writing and Content Generation</h3>
<p>Use KeyGenie to generate ideas, write blog posts, or draft essays and reports. The ability to continue and refine your writing makes it a perfect companion for authors and content creators.</p>
<h3 id="productivity-enhancement">Productivity Enhancement</h3>
<p>From email drafting to technical writing, KeyGenie can help automate and speed up repetitive tasks by generating text or providing suggestions, allowing you to work more efficiently.</p>
<h3 id="coding-assistance">Coding Assistance</h3>
<p>Developers can use KeyGenie to generate code snippets, explain functions, or debug issues. The flexibility to switch between natural language and code makes it ideal for any programming environment.</p>
<h3 id="accessibility-support">Accessibility Support</h3>
<p>With customizable text-to-speech, KeyGenie enhances accessibility for users with visual impairments or those who prefer to listen rather than read.</p>
<hr>
<h2 id="folder-structure">Folder Structure</h2>
<pre><code>KeyGenie/
â”œâ”€â”€ run<span class="hljs-selector-class">.py</span>
â”œâ”€â”€ instructions<span class="hljs-selector-class">.txt</span>
â”œâ”€â”€ brain/
â”‚   â”œâ”€â”€ backgroundai<span class="hljs-selector-class">.py</span>
â”‚   â”œâ”€â”€ defaultSettings<span class="hljs-selector-class">.json</span>
â”‚   â”œâ”€â”€ <span class="hljs-selector-tag">menu</span><span class="hljs-selector-class">.py</span>
â”‚   â”œâ”€â”€ setup<span class="hljs-selector-class">.py</span>
â”‚   â”œâ”€â”€ NotoSans-Medium<span class="hljs-selector-class">.ttf</span>
â”‚   â”œâ”€â”€ Rowdies-Regular<span class="hljs-selector-class">.ttf</span>
â”‚   â”œâ”€â”€ Ubuntu-Bold<span class="hljs-selector-class">.ttf</span>
â”‚   â”œâ”€â”€ write<span class="hljs-selector-class">.ico</span>
â”‚   â””â”€â”€ write.png
</code></pre><ul>
<li><strong>run.py:</strong> Main launcher script.</li>
<li><strong>instructions.txt:</strong> Detailed user instructions.</li>
<li><strong>brain/:</strong> Contains the core functionality and resources.<ul>
<li><strong>backgroundai.py:</strong> Main application script.</li>
<li><strong>defaultSettings.json:</strong> Default configuration settings.</li>
<li><strong>menu.py:</strong> Settings menu implementation.</li>
<li><strong>setup.py:</strong> First-time setup script.</li>
<li><strong>Fonts:</strong> Custom fonts used in the application.</li>
<li><strong>write.ico / write.png:</strong> Application icons.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="detailed-script-descriptions">Detailed Script Descriptions</h2>
<h3 id="run-py">run.py</h3>
<p>The main launcher script that initiates the application. It handles:</p>
<ul>
<li><p><strong>First-Time Setup:</strong></p>
<ul>
<li>Checks if it&#39;s the first run.</li>
<li>Executes <code>setup.py</code> to install dependencies and create necessary files.</li>
</ul>
</li>
<li><p><strong>Relaunching with pythonw.exe:</strong></p>
<ul>
<li>Uses <code>pythonw.exe</code> to run without a console window.</li>
</ul>
</li>
<li><p><strong>Starting backgroundai.py:</strong></p>
<ul>
<li>After setup, it starts the main application script.</li>
</ul>
</li>
</ul>
<pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-comment"># Check if the script is already being run by pythonw.exe</span>
    <span class="hljs-keyword">if</span> <span class="hljs-string">"pythonw"</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> sys.executable:
        relaunch_with_pythonw()

    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(first_run_file):
        <span class="hljs-comment"># First time running the script</span>
        run_script(<span class="hljs-string">'setup.py'</span>, use_pythonw=<span class="hljs-keyword">False</span>)
        <span class="hljs-keyword">with</span> open(first_run_file, <span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> f:
            f.write(<span class="hljs-string">"Setup completed"</span>)
        run_script(<span class="hljs-string">'backgroundai.py'</span>, use_pythonw=<span class="hljs-keyword">True</span>)
    <span class="hljs-keyword">else</span>:
        run_script(<span class="hljs-string">'backgroundai.py'</span>, use_pythonw=<span class="hljs-keyword">True</span>)
</code></pre>
<h3 id="backgroundai-py">backgroundai.py</h3>
<p>The core application script that:</p>
<ul>
<li><p><strong>Listens for Keyboard Events:</strong></p>
<ul>
<li>Captures prompts based on user-defined keybinds.</li>
</ul>
</li>
<li><p><strong>Interacts with OpenAI&#39;s API:</strong></p>
<ul>
<li>Sends prompts and receives AI-generated responses.</li>
</ul>
</li>
<li><p><strong>Manages System Tray Icon and Settings Menu:</strong></p>
<ul>
<li>Provides easy access to settings and controls.</li>
</ul>
</li>
<li><p><strong>Handles Text-to-Speech and Auto-Typing:</strong></p>
<ul>
<li>Types out AI responses or reads them aloud based on settings.</li>
</ul>
</li>
</ul>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemTrayIcon</span>(<span class="hljs-title">QSystemTrayIcon</span>):</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, <span class="hljs-symbol">app:</span> QApplication)</span></span>:
        <span class="hljs-keyword">super</span>().__init_<span class="hljs-number">_</span>(app)
        <span class="hljs-comment"># Initialize tray icon and menu</span>
        <span class="hljs-keyword">self</span>.setContextMenu(<span class="hljs-keyword">self</span>.menu)
        <span class="hljs-keyword">self</span>.show()
</code></pre>
<h3 id="menu-py">menu.py</h3>
<p>Implements the settings window using PyQt5:</p>
<ul>
<li><p><strong>API Key Input:</strong></p>
<ul>
<li>Allows users to enter and save their OpenAI API key.</li>
</ul>
</li>
<li><p><strong>Customizable Settings:</strong></p>
<ul>
<li>Keybinds, model selection, temperature, max tokens, and more.</li>
</ul>
</li>
<li><p><strong>Startup Management:</strong></p>
<ul>
<li>Enables or disables application launch on system startup.</li>
</ul>
</li>
</ul>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SettingsWindow</span>(<span class="hljs-title">QDialog</span>):</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        <span class="hljs-keyword">super</span>().__init_<span class="hljs-number">_</span>()
        <span class="hljs-comment"># Initialize UI components</span>
        <span class="hljs-keyword">self</span>.init_ui()
</code></pre>
<h3 id="setup-py">setup.py</h3>
<p>A script that runs on the first execution to:</p>
<ul>
<li><p><strong>Install Required Python Modules:</strong></p>
<ul>
<li>Checks for missing modules and installs them.</li>
</ul>
</li>
<li><p><strong>Create Shortcuts:</strong></p>
<ul>
<li>Adds shortcuts to the desktop and startup folder.</li>
</ul>
</li>
<li><p><strong>Ensure Dependencies are Correctly Set Up:</strong></p>
<ul>
<li>Runs post-install scripts for certain packages if necessary.</li>
</ul>
</li>
</ul>
<pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">install_missing_modules</span><span class="hljs-params">()</span></span>:
    <span class="hljs-keyword">for</span> <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">in</span> <span class="hljs-title">required_modules</span>:</span>
        <span class="hljs-keyword">if</span> importlib.util.find_spec(<span class="hljs-class"><span class="hljs-keyword">module</span>) <span class="hljs-title">is</span> <span class="hljs-title">None</span>:</span>
            subprocess.check_call([sys.executable, <span class="hljs-string">"-m"</span>, <span class="hljs-string">"pip"</span>, <span class="hljs-string">"install"</span>, <span class="hljs-class"><span class="hljs-keyword">module</span>])</span>
</code></pre>
<hr>
<h2 id="troubleshooting">Troubleshooting</h2>
<h3 id="application-doesn-t-start">Application Doesn&#39;t Start</h3>
<ul>
<li><p><strong>Ensure Python 3 is Installed:</strong></p>
<ul>
<li>Run <code>python --version</code> in the command prompt.</li>
</ul>
</li>
<li><p><strong>Check Dependencies:</strong></p>
<ul>
<li>All dependencies should install automatically.</li>
<li><p>If not, manually install them:</p>
<pre><code class="lang-bash">pip <span class="hljs-keyword">install</span> keyboard openai pyqt5 pywin32
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="cannot-find-keygenie-icon">Cannot Find KeyGenie Icon</h3>
<ul>
<li>It might be hidden in the system tray.</li>
<li>Click on the <strong>Show hidden icons</strong> arrow near the system clock.</li>
</ul>
<h3 id="permission-issues">Permission Issues</h3>
<ul>
<li>Run the application as an administrator if you encounter permission errors.</li>
</ul>
<h3 id="modules-not-installed">Modules Not Installed</h3>
<ul>
<li>If automatic installation fails, manually install the required modules.</li>
</ul>
<h3 id="typing-or-tts-doesn-t-stop">Typing or TTS Doesn&#39;t Stop</h3>
<ul>
<li>Press any key on your keyboard to interrupt the AI&#39;s typing or speech.</li>
</ul>
<hr>
<h2 id="known-issues">Known Issues</h2>
<ul>
<li><p><strong>Compatibility:</strong></p>
<ul>
<li>Currently designed for Windows operating systems.</li>
<li>Compatibility with other OSes is not guaranteed.</li>
</ul>
</li>
<li><p><strong>API Key Storage:</strong></p>
<ul>
<li>The API key is stored locally in your user directory in a folder named <code>privateVariables</code>.</li>
<li>Ensure the security of your local machine to protect your API key.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="faqs">FAQs</h2>
<h3 id="do-i-need-an-openai-api-key-">Do I need an OpenAI API key?</h3>
<p>Yes, you need a valid OpenAI API key to use KeyGenie. You can obtain one by signing up at <a href="https://platform.openai.com/signup"target=â€_blankâ€>OpenAI&#39;s website</a>.</p>
<h3 id="can-i-use-keygenie-on-macos-or-linux-">Can I use KeyGenie on macOS or Linux?</h3>
<p>Currently, KeyGenie is designed for Windows. Compatibility with macOS or Linux is not guaranteed.</p>
<h3 id="how-do-i-stop-the-ai-from-typing-or-speaking-">How do I stop the AI from typing or speaking?</h3>
<p>Press any key on your keyboard to interrupt the AI&#39;s typing or text-to-speech.</p>
<h3 id="where-is-my-api-key-stored-">Where is my API key stored?</h3>
<p>Your API key is stored locally in your user directory under <code>privateVariables/apikey.txt</code>.</p>
<h3 id="can-i-contribute-to-keygenie-">Can I contribute to KeyGenie?</h3>
<p>Yes! Contributions are welcome. Please see the <a href="#contributing">Contributing</a> section.</p>
<hr>
<h2 id="contributing">Contributing</h2>
<p>To contribute:</p>
<ol>
<li><p><strong>Fork the Project</strong></p>
<p>Click the <strong>Fork</strong> button at the top-right corner of the repository page.</p>
</li>
<li><p><strong>Create Your Feature Branch</strong></p>
<pre><code class="lang-bash">git checkout -<span class="hljs-selector-tag">b</span> feature/AmazingFeature
</code></pre>
</li>
<li><p><strong>Commit Your Changes</strong></p>
<pre><code class="lang-bash">git commit -m <span class="hljs-symbol">'Add</span> <span class="hljs-keyword">some</span> AmazingFeature'
</code></pre>
</li>
<li><p><strong>Push to the Branch</strong></p>
<pre><code class="lang-bash">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> <span class="hljs-built_in">feature</span>/AmazingFeature
</code></pre>
</li>
<li><p><strong>Open a Pull Request</strong></p>
</li>
</ol>
<hr>
<h2 id="license">License</h2>
<p>This project is licensed under the MIT License - see the <a href="https://github.com/DJJJNabba/KeyGenie/blob/main/LICENSE">LICENSE</a> file for details.</p>
<hr>
<h2 id="acknowledgments">Acknowledgments</h2>
<ul>
<li><strong>OpenAI:</strong> For providing the powerful language models.</li>
<li><strong>PyQt5 and PyWin32:</strong> For GUI and Windows API support.</li>
<li><strong>Contributors:</strong> Thanks to everyone who has contributed to this project.</li>
</ul>
<hr>
<h2 id="contact">Contact</h2>
<p>For support or inquiries, join our Discord server:</p>
<a href="https://discord.gg/cyMjN5Tk" target="_blank" class="discord-button">
    Join Discord
</a>
<hr>
<p><strong>Thank you for using KeyGenie! We hope it enhances your productivity and brings the power of AI directly to your fingertips.</strong></p>
<hr>
</section>

        <footer>
            <div class="footer-container">
                <div class="footer-logo">
                    <img src="images/nobglogo.png" alt="JJcoded Logo">
                    <p>From concept to code, turning visions into reality, driven by passion and endless curiosity.</p>
                </div>
        
                <!-- Footer Links -->
                <div class="footer-links">
                    <h3>Quick Links</h3>
                    <ul>
                        <li><a href="index.html#projects">Projects</a></li>
                        <li><a href="index.html#about">About Me</a></li>
                        <li><a href="index.html#contact">Contact</a></li>
                        <li><a href="https://github.com/DJJJNabba" target="_blank">GitHub</a></li>
                    </ul>
                </div>
        
                <!-- Social Media Icons -->
                <div class="footer-social">
                    <h3>Connect with Me</h3>
                    <a href="https://github.com/DJJJNabba" target="_blank"><i class="fab fa-github"></i></a>
                    <a href="https://www.instagram.com/jjcoded.ig/" target="_blank"><i class="fab fa-instagram"></i></a>
                    <a href="https://discord.com/channels/@me/586448690084839435" target="_blank"><i class="fab fa-discord"></i></a>
                </div>
            </div>
    
            <div class="footer-credits">
                <p>This entire website was made by me using HTML, CSS, and JavaScript. <br>
                Check out the <a href="https://github.com/DJJJNabba/JJcoded" target="_blank">GitHub repo</a> for the website.</p>
            </div>
        
            <!-- Copyright and Credits -->
            <div class="footer-bottom">
                <p>&copy; 2024 JJcoded. All Rights Reserved.</p>
                <p>Made with ðŸ’» and ðŸš«ðŸ˜´ by Jackson.</p>
            </div>
        </footer>  
        
        

    <!-- Prism JS for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-python.min.js"></script>

    <!-- Carousel and Code Tab Script -->
    <script>
        let slideIndex = 0;
        let autoSlideInterval; // Store the auto-slide interval
        const slideDuration = 4000; // 4 seconds for each image
        let slides; // Declare slides here to initialize later
    
        function initCarousel() {
            slides = document.querySelectorAll(".carousel-item"); // Get all slides after DOM is loaded
            showSlides(slideIndex);
            autoSlideInterval = setInterval(autoShowSlides, slideDuration); // Start auto slide for images
        }
    
        function plusSlides(n) {
            showSlides(slideIndex += n);
            resetAutoSlide(); // Reset the auto-slide when manually navigating
        }
    
        function autoShowSlides() {
            const currentSlide = slides[slideIndex];
            
            // If the current slide is not a video, auto-show the next slide after 4 seconds
            if (currentSlide.tagName !== "VIDEO") {
                slideIndex++;
                showSlides(slideIndex);
            }
        }
    
        function showSlides(n) {
            if (n >= slides.length) {
                slideIndex = 0;  // Go back to the first slide
            } else if (n < 0) {
                slideIndex = slides.length - 1;  // Go to the last slide
            }
    
            // Hide all slides
            slides.forEach(slide => {
                slide.style.display = "none";
                if (slide.tagName === "VIDEO") {
                    slide.pause(); // Pause any videos if they are playing
                    slide.currentTime = 0; // Reset video to start
                }
            });
    
            // Show the current slide
            const currentSlide = slides[slideIndex];
            currentSlide.style.display = "block";
    
            // If the current slide is a video, play it and only advance after it's done
            if (currentSlide.tagName === "VIDEO") {
                currentSlide.play();
                currentSlide.onended = function () {
                    plusSlides(1);  // Move to the next slide when the video finishes
                };
                clearInterval(autoSlideInterval); // Stop auto-slide during video playback
            } else {
                resetAutoSlide(); // Restart auto-slide if an image is displayed
            }
        }
    
        function resetAutoSlide() {
            clearInterval(autoSlideInterval); // Clear the current interval
            autoSlideInterval = setInterval(autoShowSlides, slideDuration); // Restart auto-slide after 4 seconds
        }
    
        window.onload = function () {
            initCarousel(); // Initialize the carousel on page load
            showCode('RUN.py');  // Display main.py content by default
        };
    
    const codeFiles = {
    // Root level Python files
    'RUN.py': `import subprocess
import sys
import os

# Path to the first run indicator file in the 'brain' folder
brain_folder = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'brain')
first_run_file = os.path.join(brain_folder, "first_run.txt")

def get_pythonw_path():
    """Find pythonw.exe in the current Python installation directory."""
    python_dir = os.path.dirname(sys.executable)  # Get the directory of the current Python interpreter
    pythonw_path = os.path.join(python_dir, 'pythonw.exe')  # Path to pythonw.exe
    if os.path.exists(pythonw_path):
        return pythonw_path
    else:
        return None  # Return None if pythonw.exe is not found
# this is not a comment
def relaunch_with_pythonw():
    """Relaunch the script using pythonw.exe to avoid showing the terminal window."""
    pythonw_executable = get_pythonw_path()
    if pythonw_executable:
        # Relaunch using pythonw.exe
        subprocess.Popen([pythonw_executable, __file__], close_fds=True)
        sys.exit(0)  # Exit the current instance to prevent double execution

def run_script(script_name, use_pythonw=True):
    """Run the given Python script located in the 'brain' folder."""
    try:
        script_path = os.path.join(brain_folder, script_name)
        python_executable = get_pythonw_path() if use_pythonw else sys.executable
        result = subprocess.run([python_executable, script_path], check=True)
        return result.returncode == 0
    except subprocess.CalledProcessError:
        return False

def main():
    # Check if the script is already being run by pythonw.exe
    if "pythonw" not in sys.executable:
        relaunch_with_pythonw()  # Relaunch using pythonw.exe if it is not already running with it

    if not os.path.exists(first_run_file):
        # First time running the script
        print("First run detected. Running setup.py...")

        # Run setup.py and retry if it fails
        if not run_script('setup.py', use_pythonw=False):  # Use python.exe for setup
            print("setup.py failed. Retrying...")
            if not run_script('setup.py', use_pythonw=False):
                print("setup.py failed twice. Exiting.")
                return

        # Setup completed, create first_run_file in 'brain' folder
        with open(first_run_file, 'w') as f:
            f.write("Setup completed")

        # Now run backgroundai.py using pythonw.exe
        print("Running backgroundai.py...")
        run_script('backgroundai.py', use_pythonw=True)

    else:
        # Not the first run, just run backgroundai.py using pythonw.exe
        print("Not the first run. Running backgroundai.py...")
        run_script('backgroundai.py', use_pythonw=True)

if __name__ == "__main__":
    main()
`,
    'instructions.txt': `Instructions for AIKeyboard

Thank you for using AIKeyboard! This application allows you to interact with OpenAI's language models directly from your keyboard.

---

Getting Started

1. Ensure Python 3 is Installed

   - Check if Python is installed:
     - Open Command Prompt (Windows) or Terminal (Mac/Linux).
     - Type python --version and press Enter.
     - If Python 3 is installed, it will display the version number (e.g., Python 3.8.5).
   
   - If Python is not installed:
     - Download Python 3 from https://www.python.org/downloads/.
     - Install Python by following the instructions on the website.

2. Run the Application

   - First Run:
     - Navigate to the folder containing run.py.
     - Double-click run.py to run it.
     - Alternatively, you can run it from the command line:
       - Open Command Prompt or Terminal.
       - Navigate to your project folder using cd commands.
       - Run python run.py.
   
   - First Time Setup:
     - On the first run, the application will automatically install all the necessary Python modules.
     - Please be patient as this may take a few minutes.
     - A file named first_run.txt will be created inside the brain folder after setup is complete.

3. Provide Your OpenAI API Key

   - After running the application, you'll find an AIKeyboard icon in your system tray (near the clock on your taskbar).
   
   - For Windows Users:
     - Look for a small icon resembling a keyboard or AI assistant.
     - You might need to click on the "Show hidden icons" arrow to see it.
   
   - Access Settings:
     - Right-click the AIKeyboard icon and select "Open Settings".
   
   - Enter API Key:
     - In the settings window, enter your OpenAI API key in the "API Key" field.
     - Click "Save API Key" to save your key.
   
   - Note: You need a valid OpenAI API key to use this application. Sign up at https://platform.openai.com/signup/ if you don't have one.

4. Configure Settings (Optional)

   - Model Selection:
     - Choose which OpenAI model to use from the dropdown menu.
   
   - Custom Instructions:
     - Add any custom instructions for the AI in the provided text area.
   
   - Keybinds:
     - Set the keys you use to activate the AI.
     - Prompt Keybind: Starts a new AI prompt.
     - Completion Keybind: Asks the AI to continue your text.
   
   - Additional Settings:
     - Temperature: Controls the randomness of the AI's responses.
     - Max Tokens: Limits the length of the AI's responses.
     - Auto-Type: Enable or disable automatic typing of AI responses.
     - Typing Speed: Adjust how fast the AI types back.
     - Letter by Letter Typing: Choose whether the AI types letter by letter or in chunks.
     - Play TTS: Enable text-to-speech to have the AI speak responses.
     - TTS Rate: Adjust the speaking rate of the AI.
   
   - Save Settings:
     - Don't forget to click "Save Settings" after making changes.

5. Using AIKeyboard

   - Activate Prompt Mode:
     - Press the "Prompt Keybind" (default is right shift) to start capturing your input.
     - Type your prompt, and press the keybind again to stop capturing.
     - The AI will process your input and type out the response automatically.
   
   - Activate Completion Mode:
     - Press the "Completion Keybind" (default is right ctrl) to start capturing text to be completed.
     - Type the text you want the AI to continue, and press the keybind again to stop capturing.
     - The AI will generate a continuation of your text.
   
   - Stopping the AI Typing or TTS:
     - To stop the AI from typing or speaking, press any key on your keyboard.

6. Exiting the Application

   - To exit AIKeyboard, right-click the system tray icon and select "Quit".

---

Additional Notes

- Python Version:
  - Ensure you have Python 3 installed. The application may not work correctly with older versions.
  
- Dependencies:
  - The application will automatically install necessary Python modules on the first run. Although you may need to restart the program for changes to take effect.
  
- Privacy:
  - Your OpenAI API key is stored locally in your user directory in a folder named privateVariables.
  
- Support:
  - If you encounter any issues, please reach out my discord - @djjj.

---

Troubleshooting

- Application Doesn't Start:
  - Make sure you have Python 3 installed and added to your system's PATH.
  - Ensure all files are in the correct folders as specified in the folder structure.

- Cannot Find AIKeyboard Icon:
  - It might be hidden in the system tray. Click on the arrow to show hidden icons.

- Modules Not Installed:
  - If the necessary Python modules are not installed, you can manually install them by running:
    pip install -r requirements.txt
    Note: You may need to create a requirements.txt file listing all dependencies.

- Permission Issues:
  - Run the application as an administrator if you encounter permission errors.

---

Uninstallation

- To Uninstall the Application:
  - Delete the project folder.
  - Remove any shortcuts or startup entries if you enabled them in settings.
  - Delete the privateVariables folder located in your user directory to remove saved settings and API keys.

---

Thank You for Using AIKeyboard!
`,
    // brain folder
    'setup.py': `import os
import shutil
import sys
import subprocess
import importlib.util
import ctypes
from ctypes import wintypes

# Define required modules for backgroundai.py
required_modules = [
    "keyboard",
    "openai",
    "pystray",
    "Pillow",   # for handling images
    "PyQt5",    # for GUI (Qt-based settings menu)
    "pywin32",  # Includes win32com.client and pythoncom for Windows API usage
]

# Install required modules if they are not already installed
def install_missing_modules():
    for module in required_modules:
        if importlib.util.find_spec(module) is None:
            print(f"Module '{module}' is not installed. Installing...")
            subprocess.check_call([sys.executable, "-m", "pip", "install", module])
        else:
            print(f"Module '{module}' is already installed.")

# Function to run the pywin32_postinstall script manually
def run_pywin32_postinstall():
    try:
        pywin32_postinstall_path = os.path.join(os.path.dirname(sys.executable), 'Scripts', 'pywin32_postinstall.py')
        if os.path.exists(pywin32_postinstall_path):
            print("Running pywin32 post-install script...")
            subprocess.check_call([sys.executable, pywin32_postinstall_path, "-install"])
            print("pywin32 post-install completed.")
        else:
            print("Could not find pywin32_postinstall script.")
    except Exception as e:
        print(f"Error running pywin32_postinstall: {e}")

# Run post-install for pywin32 if required
def ensure_pywin32_postinstall():
    try:
        # Import win32com.client and pythoncom to ensure they are set up
        import win32com.client
        import pythoncom
        print("win32com and pythoncom are correctly set up.")
    except ImportError:
        # If the imports fail, run the pywin32 post-install
        run_pywin32_postinstall()

# Ensure that pywin32 is set up before proceeding
install_missing_modules()
ensure_pywin32_postinstall()

# Now, import win32com.client after ensuring it is installed
from win32com.client import Dispatch

# Get the directory where the current setup script is located
script_directory = os.path.dirname(os.path.abspath(__file__))

# Define paths dynamically
user_profile = os.getenv('USERPROFILE')  # Dynamically get user's home directory
appdata_folder = os.getenv('APPDATA')
startup_folder = os.path.join(appdata_folder, r'Microsoft\Windows\Start Menu\Programs\Startup')

# Function to find the user's desktop folder path using Windows API
def get_desktop_path():
    CSIDL_DESKTOP = 0  # CSIDL_DESKTOP is the constant for desktop
    SHGFP_TYPE_CURRENT = 0  # Constant for getting the current path

    buf = ctypes.create_unicode_buffer(wintypes.MAX_PATH)
    ctypes.windll.shell32.SHGetFolderPathW(None, CSIDL_DESKTOP, None, SHGFP_TYPE_CURRENT, buf)
    return buf.value

# Use Windows API to find the desktop path
desktop_folder = get_desktop_path()

# Define shortcut details
shortcut_name = "AIKeyboard.lnk"
background_script_path = os.path.join(script_directory, "backgroundai.py")  # Path to backgroundai.py
start_in_directory = script_directory  # Start in the directory where the script is located
icon_path = os.path.join(script_directory, "write.ico")  # Using write.ico for the icon

# Function to find pythonw.exe based on the current Python interpreter location
def find_pythonw():
    python_dir = os.path.dirname(sys.executable)  # Get the directory of the current Python interpreter
    pythonw_path = os.path.join(python_dir, 'pythonw.exe')  # pythonw.exe is usually in the same directory
    if os.path.exists(pythonw_path):
        return pythonw_path
    else:
        return None

# Create a shortcut at the specified path
def create_shortcut(shortcut_path, target, start_in, icon):
    shell = Dispatch('WScript.Shell')
    shortcut = shell.CreateShortCut(shortcut_path)
    shortcut.Targetpath = target
    shortcut.Arguments = f'"{background_script_path}"'  # Script to run
    shortcut.WorkingDirectory = start_in
    shortcut.IconLocation = f"{icon}, 0"  # Set icon with index 0 for the .ico file
    shortcut.save()

# Check for pythonw.exe and ensure it's found
pythonw_executable = find_pythonw()
if pythonw_executable is None:
    print("Could not find pythonw.exe. Please ensure Python is installed.")
    sys.exit(1)

# Full paths for shortcuts in the startup folder and on the desktop
startup_shortcut = os.path.join(startup_folder, shortcut_name)
desktop_shortcut = os.path.join(desktop_folder, shortcut_name)

# Check if the shortcut already exists in the startup folder
if not os.path.exists(startup_shortcut):
    create_shortcut(startup_shortcut, pythonw_executable, start_in_directory, icon_path)
    print(f"Shortcut created in Startup folder: {startup_shortcut}")
else:
    print(f"Shortcut already exists in Startup folder: {startup_shortcut}")

# Create a shortcut on the desktop if it doesn't exist
if not os.path.exists(desktop_shortcut):
    create_shortcut(desktop_shortcut, pythonw_executable, start_in_directory, icon_path)
    print(f"Shortcut created on Desktop: {desktop_shortcut}")
else:
    print(f"Shortcut already exists on Desktop: {desktop_shortcut}")

# ------------------ Added Code to Ensure Files Exist ------------------

# Define the paths for the private variables and files
PRIVATE_FOLDER = os.path.join(os.path.expanduser("~"), "privateVariables")
API_KEY_FILE = os.path.join(PRIVATE_FOLDER, "apikey.txt")
KEYBINDS_FILE = os.path.join(PRIVATE_FOLDER, "keybinds.txt")
MODEL_FILE = os.path.join(PRIVATE_FOLDER, "model.txt")
SETTINGS_FILE = os.path.join(PRIVATE_FOLDER, "settings.txt")
CUSTOM_INSTRUCTIONS_FILE = os.path.join(PRIVATE_FOLDER, "custom_instructions.txt")

# Default values
DEFAULT_KEYBINDS = {
    "prompt": "right shift",
    "completion": "right ctrl"
}

DEFAULT_MODEL = "gpt-3.5-turbo"

DEFAULT_SETTINGS = {
    "temperature": 1.0,
    "max_tokens": 256,
    "auto_type": True,
    "typing_speed_wpm": 350,
    "letter_by_letter": True,
    "play_tts": True,
    "tts_rate": 4
}

# Ensure the private variables folder exists
if not os.path.exists(PRIVATE_FOLDER):
    os.makedirs(PRIVATE_FOLDER)
    print(f"Created private variables folder at {PRIVATE_FOLDER}")

# Ensure API_KEY_FILE exists
if not os.path.exists(API_KEY_FILE):
    with open(API_KEY_FILE, 'w') as f:
        f.write('')
    print(f"Created API key file at {API_KEY_FILE}")

# Ensure KEYBINDS_FILE exists
if not os.path.exists(KEYBINDS_FILE):
    with open(KEYBINDS_FILE, 'w') as f:
        for action, key in DEFAULT_KEYBINDS.items():
            f.write(f"{action}: {key}\n")
    print(f"Created keybinds file at {KEYBINDS_FILE}")

# Ensure MODEL_FILE exists
if not os.path.exists(MODEL_FILE):
    with open(MODEL_FILE, 'w') as f:
        f.write(DEFAULT_MODEL)
    print(f"Created model file at {MODEL_FILE}")

# Ensure SETTINGS_FILE exists
if not os.path.exists(SETTINGS_FILE):
    with open(SETTINGS_FILE, 'w') as f:
        for key, value in DEFAULT_SETTINGS.items():
            f.write(f"{key}:{value}\n")
    print(f"Created settings file at {SETTINGS_FILE}")

# Ensure CUSTOM_INSTRUCTIONS_FILE exists
if not os.path.exists(CUSTOM_INSTRUCTIONS_FILE):
    with open(CUSTOM_INSTRUCTIONS_FILE, 'w', encoding='utf-8') as f:
        f.write('')
    print(f"Created custom instructions file at {CUSTOM_INSTRUCTIONS_FILE}")

# ----------------------------------------------------------------------

# Run the background script with pythonw.exe
print("Running backgroundai.py with pythonw.exe...")
subprocess.Popen([pythonw_executable, background_script_path])
`,
    'menu.py': `import os
import shutil
import sys
import ctypes
import keyboard
from ctypes import wintypes
from PyQt5.QtWidgets import (QApplication, QWidget, QLabel, QLineEdit, QTextEdit, QPushButton,
                             QVBoxLayout, QHBoxLayout, QSlider, QCheckBox, QComboBox, QMessageBox,
                             QScrollArea, QDialog)
from PyQt5.QtCore import Qt
from win32com.client import Dispatch

# File paths for saving settings
PRIVATE_FOLDER = os.path.join(os.path.expanduser("~"), "privateVariables")
API_KEY_FILE = os.path.join(PRIVATE_FOLDER, "apikey.txt")
KEYBINDS_FILE = os.path.join(PRIVATE_FOLDER, "keybinds.txt")
MODEL_FILE = os.path.join(PRIVATE_FOLDER, "model.txt")
SETTINGS_FILE = os.path.join(PRIVATE_FOLDER, "settings.txt")
CUSTOM_INSTRUCTIONS_FILE = os.path.join(PRIVATE_FOLDER, "custom_instructions.txt")

# Default keybinds and settings
DEFAULT_KEYBINDS = {
    "prompt": "right shift",
    "completion": "right ctrl"
}
DEFAULT_MODEL = "gpt-4o-mini-2024-07-18"
DEFAULT_SETTINGS = {
    "temperature": 1.0,
    "max_tokens": 256,
    "auto_type": True,
    "typing_speed_wpm": 200,
    "letter_by_letter": True,  # Default to letter-by-letter typing
    "play_tts": False,         # Default to not playing TTS
    "tts_rate": 0              # Default TTS rate
}

# Startup shortcut paths
APPDATA_FOLDER = os.getenv('APPDATA')
STARTUP_SHORTCUT_PATH = os.path.join(APPDATA_FOLDER, r'Microsoft\Windows\Start Menu\Programs\Startup', 'AIKeyboard.lnk')

def load_or_create_api_key():
    """Load or create an API key."""
    if not os.path.exists(PRIVATE_FOLDER):
        os.makedirs(PRIVATE_FOLDER)

    if os.path.exists(API_KEY_FILE):
        with open(API_KEY_FILE, "r") as file:
            api_key = file.read().strip()
        if api_key:
            return api_key
    return ""


def load_or_create_keybinds():
    """Load or create keybinds."""
    if not os.path.exists(PRIVATE_FOLDER):
        os.makedirs(PRIVATE_FOLDER)

    if os.path.exists(KEYBINDS_FILE):
        with open(KEYBINDS_FILE, "r") as file:
            lines = file.readlines()
            keybinds = {line.split(":")[0]: line.split(":")[1].strip() for line in lines}
            return keybinds

    return DEFAULT_KEYBINDS.copy()


def save_keybinds(keybinds):
    """Save keybinds to a file."""
    with open(KEYBINDS_FILE, "w") as file:
        for action, key in keybinds.items():
            file.write(f"{action}: {key}\n")


def load_selected_model():
    """Load the selected model from file."""
    if os.path.exists(MODEL_FILE):
        with open(MODEL_FILE, "r") as file:
            model_id = file.read().strip()
        return model_id
    return DEFAULT_MODEL


def save_selected_model(model_id):
    """Save the selected model to file."""
    with open(MODEL_FILE, "w") as file:
        file.write(model_id)


def enable_startup():
    """Enable the app to run on startup by creating a shortcut."""
    script_directory = os.path.dirname(os.path.abspath(__file__))
    shortcut_target = os.path.join(script_directory, "backgroundai.py")
    pythonw_executable = shutil.which("pythonw")

    if not pythonw_executable:
        pythonw_executable = sys.executable  # Fallback to current Python executable if pythonw.exe is not found

    icon_path = os.path.join(script_directory, "write.ico")

    shell = Dispatch('WScript.Shell')
    shortcut = shell.CreateShortCut(STARTUP_SHORTCUT_PATH)
    shortcut.Targetpath = pythonw_executable
    shortcut.Arguments = f'"{shortcut_target}"'
    shortcut.WorkingDirectory = script_directory
    shortcut.IconLocation = f"{icon_path}, 0"  # Set the icon location
    shortcut.save()

    QMessageBox.information(None, "Startup Enabled", "The application is now set to run at startup.")


def disable_startup():
    """Disable the app from running on startup by removing the shortcut."""
    if os.path.exists(STARTUP_SHORTCUT_PATH):
        os.remove(STARTUP_SHORTCUT_PATH)
        QMessageBox.information(None, "Startup Disabled", "The application is no longer set to run at startup.")
    else:
        QMessageBox.warning(None, "Already Disabled", "The application is not set to run at startup.")


def load_custom_instructions():
    """Load custom instructions from file."""
    if os.path.exists(CUSTOM_INSTRUCTIONS_FILE):
        with open(CUSTOM_INSTRUCTIONS_FILE, "r", encoding='utf-8') as file:
            instructions = file.read()
            return instructions
    else:
        return ""


def save_custom_instructions(instructions):
    """Save custom instructions to file."""
    with open(CUSTOM_INSTRUCTIONS_FILE, "w", encoding='utf-8') as file:
        file.write(instructions)


def load_settings():
    """Load settings from file or use default settings."""
    settings = DEFAULT_SETTINGS.copy()
    if os.path.exists(SETTINGS_FILE):
        with open(SETTINGS_FILE, "r") as file:
            lines = file.readlines()
            for line in lines:
                if ":" not in line:
                    continue  # Skip malformed lines
                key, value = line.strip().split(":", 1)
                if key == "temperature":
                    settings["temperature"] = float(value)
                elif key == "max_tokens":
                    settings["max_tokens"] = int(value)
                elif key == "auto_type":
                    settings["auto_type"] = value.lower() == 'true'
                elif key == "typing_speed_wpm":
                    settings["typing_speed_wpm"] = int(value)
                elif key == "letter_by_letter":
                    settings["letter_by_letter"] = value.lower() == 'true'
                elif key == "play_tts":
                    settings["play_tts"] = value.lower() == 'true'
                elif key == "tts_rate":
                    try:
                        settings["tts_rate"] = int(value)
                    except ValueError:
                        settings["tts_rate"] = DEFAULT_SETTINGS["tts_rate"]
    return settings


def save_settings(settings):
    """Save settings to a file."""
    with open(SETTINGS_FILE, "w") as file:
        for key, value in settings.items():
            file.write(f"{key}:{value}\n")


class SettingsWindow(QDialog):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Settings Menu")
        self.setGeometry(100, 100, 500, 600)

        self.init_ui()
        self.current_action = None  # Track which keybind is being set
        self.api_key_visible = False  # Track visibility of the API key

    def init_ui(self):
        main_layout = QVBoxLayout(self)
        
        # Create a scroll area
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        
        # Create a widget to contain all the settings
        self.content_widget = QWidget()
        content_layout = QVBoxLayout(self.content_widget)
        
        # 1. API Key Section
        api_key_layout = QHBoxLayout()  # Create a horizontal layout for the API Key section

        self.api_key_label = QLabel("API Key:")
        content_layout.addWidget(self.api_key_label)

        self.api_key_input = QLineEdit()
        self.api_key_input.setEchoMode(QLineEdit.Password)  # Hide API key by default
        api_key_layout.addWidget(self.api_key_input)

        # Show/Hide button next to the API key input
        self.toggle_api_key_button = QPushButton("Show")
        self.toggle_api_key_button.setFixedWidth(100)  # Set a fixed width for the button
        self.toggle_api_key_button.clicked.connect(self.toggle_api_key_visibility)
        api_key_layout.addWidget(self.toggle_api_key_button)

        # Add the horizontal layout for API Key and Show/Hide button to the main content layout
        content_layout.addLayout(api_key_layout)

        # Save button for API key (this stays on a new line)
        self.save_api_button = QPushButton("Save API Key")
        self.save_api_button.clicked.connect(self.save_api_key)
        content_layout.addWidget(self.save_api_button)

        # Load the API key after creating the layout
        self.load_api_key()
        
        # 2. Model Selection Section
        self.model_label = QLabel("Model Selection:")
        content_layout.addWidget(self.model_label)
        
        self.model_combo_box = QComboBox()
        model_ids = [
            # Chat models
            'gpt-4',
            'gpt-4-0613',
            'gpt-4-1106-preview',
            'gpt-4-turbo',
            'gpt-4-turbo-2024-04-09',
            'gpt-4-turbo-preview',
            'gpt-4o',
            'gpt-4o-2024-05-13',
            'gpt-4o-mini',
            'gpt-4o-mini-2024-07-18',
            'gpt4o-0806-loco-vm',
            'gpt-3.5-turbo',
            'gpt-3.5-turbo-16k',
            'gpt-3.5-turbo-0125',
            'gpt-3.5-turbo-1106',
            'gpt-3.5-turbo-instruct',  # Legacy completion model
            'gpt-3.5-turbo-instruct-0914',  # Legacy completion model
            # Legacy completion models
            'davinci-002',
            'babbage-002',
            'text-davinci-003',
            'text-curie-001',
            'text-babbage-001',
            'text-ada-001',
        ]
        self.model_combo_box.addItems(model_ids)
        content_layout.addWidget(self.model_combo_box)
        
        selected_model = load_selected_model()
        if selected_model in model_ids:
            index = model_ids.index(selected_model)
            self.model_combo_box.setCurrentIndex(index)
        else:
            self.model_combo_box.setCurrentIndex(0)
        
        self.model_combo_box.currentIndexChanged.connect(self.on_model_selection_changed)
        
        # 3. Custom Instructions Section
        self.custom_instructions_label = QLabel("Custom Instructions:")
        content_layout.addWidget(self.custom_instructions_label)
        
        self.custom_instructions_text = QTextEdit()
        self.custom_instructions_text.setPlaceholderText("Enter custom instructions for the AI here...")
        self.custom_instructions_text.setPlainText(load_custom_instructions())
        content_layout.addWidget(self.custom_instructions_text)
        
        self.save_instructions_button = QPushButton("Save Instructions")
        self.save_instructions_button.clicked.connect(self.save_custom_instructions)
        content_layout.addWidget(self.save_instructions_button)
        
        # 4. Keybinds Section
        self.keybinds_label = QLabel("Keybinds:")
        content_layout.addWidget(self.keybinds_label)

        # Prompt Keybind Layout (Text field and button on the same line)
        prompt_keybind_layout = QHBoxLayout()
        self.prompt_keybind_label = QLabel("Prompt Keybind:")
        prompt_keybind_layout.addWidget(self.prompt_keybind_label)

        self.prompt_keybind_input = QLineEdit()
        self.prompt_keybind_input.setReadOnly(True)
        prompt_keybind_layout.addWidget(self.prompt_keybind_input)

        self.prompt_keybind_button = QPushButton("Set")
        self.prompt_keybind_button.setFixedWidth(100)  # Set a fixed width to make the button smaller
        self.prompt_keybind_button.clicked.connect(lambda: self.select_keybind("prompt", self.prompt_keybind_button))
        prompt_keybind_layout.addWidget(self.prompt_keybind_button)

        content_layout.addLayout(prompt_keybind_layout)

        # Completion Keybind Layout (Text field and button on the same line)
        completion_keybind_layout = QHBoxLayout()
        self.completion_keybind_label = QLabel("Completion Keybind:")
        completion_keybind_layout.addWidget(self.completion_keybind_label)

        self.completion_keybind_input = QLineEdit()
        self.completion_keybind_input.setReadOnly(True)
        completion_keybind_layout.addWidget(self.completion_keybind_input)

        self.completion_keybind_button = QPushButton("Set")
        self.completion_keybind_button.setFixedWidth(100)  # Set a fixed width to make the button smaller
        self.completion_keybind_button.clicked.connect(lambda: self.select_keybind("completion", self.completion_keybind_button))
        completion_keybind_layout.addWidget(self.completion_keybind_button)

        content_layout.addLayout(completion_keybind_layout)

        
        self.load_keybinds()
        
        self.revert_keybinds_button = QPushButton("Revert to Default Keybinds")
        self.revert_keybinds_button.clicked.connect(self.revert_to_default_keybinds)
        content_layout.addWidget(self.revert_keybinds_button)
        
        # 5. Additional Settings (Temperature, Max Tokens, Typing, TTS)
        self.settings_label = QLabel("Additional Settings:")
        content_layout.addWidget(self.settings_label)
        
        self.settings = load_settings()
        
        # Temperature Slider
        temp_layout = QHBoxLayout()
        self.temperature_label = QLabel(f"Temperature: {self.settings['temperature']}")
        temp_layout.addWidget(self.temperature_label)
        
        self.temperature_slider = QSlider(Qt.Horizontal)
        self.temperature_slider.setMinimum(0)
        self.temperature_slider.setMaximum(20)  # Slider steps from 0 to 20 representing 0.0 to 2.0
        self.temperature_slider.setValue(int(self.settings['temperature'] * 10))
        self.temperature_slider.valueChanged.connect(self.on_temperature_changed)
        temp_layout.addWidget(self.temperature_slider)
        content_layout.addLayout(temp_layout)
        
        # Max Tokens Input
        max_tokens_layout = QHBoxLayout()
        self.max_tokens_label = QLabel("Max Completion Tokens:")
        max_tokens_layout.addWidget(self.max_tokens_label)
        
        self.max_tokens_input = QLineEdit(str(self.settings['max_tokens']))
        max_tokens_layout.addWidget(self.max_tokens_input)
        content_layout.addLayout(max_tokens_layout)
        
        # Auto-Type Checkbox
        self.auto_type_checkbox = QCheckBox("Auto-Type")
        self.auto_type_checkbox.setChecked(self.settings.get('auto_type', True))
        self.auto_type_checkbox.stateChanged.connect(self.on_auto_type_changed)
        content_layout.addWidget(self.auto_type_checkbox)
        
        # Typing Speed Slider
        self.typing_speed_layout = QHBoxLayout()
        self.typing_speed_label = QLabel(f"Typing Speed: {self.settings['typing_speed_wpm']} WPM")
        self.typing_speed_layout.addWidget(self.typing_speed_label)
        
        self.typing_speed_slider = QSlider(Qt.Horizontal)
        self.typing_speed_slider.setMinimum(10)
        self.typing_speed_slider.setMaximum(1000)
        self.typing_speed_slider.setValue(self.settings['typing_speed_wpm'])
        self.typing_speed_slider.valueChanged.connect(self.on_typing_speed_changed)
        self.typing_speed_layout.addWidget(self.typing_speed_slider)
        content_layout.addLayout(self.typing_speed_layout)
        
        # Letter by Letter Checkbox (only visible if Auto-Type is enabled)
        self.letter_by_letter_checkbox = QCheckBox("Letter by Letter Typing")
        self.letter_by_letter_checkbox.setChecked(self.settings.get('letter_by_letter', True))
        self.letter_by_letter_checkbox.stateChanged.connect(self.on_letter_by_letter_changed)
        content_layout.addWidget(self.letter_by_letter_checkbox)
        
        # Play TTS Checkbox
        self.play_tts_checkbox = QCheckBox("Play TTS")
        self.play_tts_checkbox.setChecked(self.settings.get('play_tts', False))
        self.play_tts_checkbox.stateChanged.connect(self.on_play_tts_changed)
        content_layout.addWidget(self.play_tts_checkbox)
        
        # TTS Rate Slider (initially hidden)
        self.tts_rate_layout = QHBoxLayout()
        self.tts_rate_label = QLabel(f"TTS Rate: {self.settings.get('tts_rate', 0)}")
        self.tts_rate_layout.addWidget(self.tts_rate_label)
        
        self.tts_rate_slider = QSlider(Qt.Horizontal)
        self.tts_rate_slider.setMinimum(-10)
        self.tts_rate_slider.setMaximum(10)
        self.tts_rate_slider.setValue(self.settings.get('tts_rate', 0))
        self.tts_rate_slider.valueChanged.connect(self.on_tts_rate_changed)
        self.tts_rate_layout.addWidget(self.tts_rate_slider)
        content_layout.addLayout(self.tts_rate_layout)
        
        self.tts_rate_slider.setVisible(self.play_tts_checkbox.isChecked())
        self.tts_rate_label.setVisible(self.play_tts_checkbox.isChecked())
        
        # 6. Startup Buttons
        startup_buttons_layout = QHBoxLayout()
        
        self.enable_startup_button = QPushButton("Enable from Startup")
        self.enable_startup_button.clicked.connect(enable_startup)
        startup_buttons_layout.addWidget(self.enable_startup_button)
        
        self.disable_startup_button = QPushButton("Disable from Startup")
        self.disable_startup_button.clicked.connect(disable_startup)
        startup_buttons_layout.addWidget(self.disable_startup_button)
        
        content_layout.addLayout(startup_buttons_layout)
        
        # 7. Save and Revert Buttons
        self.save_settings_button = QPushButton("Save Settings")
        self.save_settings_button.clicked.connect(self.save_additional_settings)
        content_layout.addWidget(self.save_settings_button)
        
        self.revert_settings_button = QPushButton("Revert to Default Settings")
        self.revert_settings_button.clicked.connect(self.revert_to_default_settings)
        content_layout.addWidget(self.revert_settings_button)
        
        # Finalize the layout with the scroll area
        self.scroll_area.setWidget(self.content_widget)
        main_layout.addWidget(self.scroll_area)


    def load_api_key(self):
        api_key = load_or_create_api_key()
        if api_key:
            self.api_key_input.setText(api_key)

    def save_api_key(self):
        api_key = self.api_key_input.text().strip()
        if api_key:
            with open(API_KEY_FILE, "w") as file:
                file.write(api_key)
            QMessageBox.information(self, "Success", "API key saved successfully!")
        else:
            QMessageBox.warning(self, "Error", "No API key provided!")

    def toggle_api_key_visibility(self):
        """Toggle the visibility of the API key."""
        if self.api_key_visible:
            self.api_key_input.setEchoMode(QLineEdit.Password)
            self.toggle_api_key_button.setText("Show")
        else:
            self.api_key_input.setEchoMode(QLineEdit.Normal)
            self.toggle_api_key_button.setText("Hide")
        self.api_key_visible = not self.api_key_visible

    def load_keybinds(self):
        self.keybinds = load_or_create_keybinds()
        self.prompt_keybind_input.setText(self.keybinds["prompt"])
        self.completion_keybind_input.setText(self.keybinds["completion"])

    def save_keybinds_to_file(self):
        save_keybinds(self.keybinds)

    def select_keybind(self, action, button):
        """Change the button color and wait for key input."""
        if self.current_action:
            return  # Prevent setting multiple keybinds at once

        self.current_action = action
        button.setStyleSheet("background-color: yellow")

        # Use keyboard.hook to detect the key press in the background
        def on_key_event(event):
            if event.event_type == "down":  # Only capture key down events
                key = event.name
                if action == "prompt":
                    self.keybinds["prompt"] = key
                    self.prompt_keybind_input.setText(key)
                elif action == "completion":
                    self.keybinds["completion"] = key
                    self.completion_keybind_input.setText(key)

                self.save_keybinds_to_file()  # Save keybinds after setting

                # Reset the button color
                button.setStyleSheet("")
                keyboard.unhook_all()  # Stop listening for keyboard events
                self.current_action = None

        keyboard.hook(on_key_event)  # Hook keyboard events for key detection

    def revert_to_default_keybinds(self):
        """Revert to default keybinds and update UI."""
        self.keybinds = DEFAULT_KEYBINDS.copy()
        self.prompt_keybind_input.setText(self.keybinds["prompt"])
        self.completion_keybind_input.setText(self.keybinds["completion"])
        self.save_keybinds_to_file()
        QMessageBox.information(self, "Info", "Keybinds reverted to default!")

    def on_model_selection_changed(self):
        """Save the selected model when the selection changes."""
        model_id = self.model_combo_box.currentText()
        save_selected_model(model_id)

    def on_temperature_changed(self):
        """Update temperature label when the slider value changes."""
        temperature = self.temperature_slider.value() / 10.0
        self.temperature_label.setText(f"Temperature: {temperature}")
        self.settings['temperature'] = temperature

    def on_auto_type_changed(self):
        """Show or hide typing speed and letter-by-letter checkbox based on auto-type checkbox."""
        auto_type_enabled = self.auto_type_checkbox.isChecked()
        self.settings['auto_type'] = auto_type_enabled
        self.typing_speed_slider.setVisible(auto_type_enabled)
        self.typing_speed_label.setVisible(auto_type_enabled)
        self.letter_by_letter_checkbox.setVisible(auto_type_enabled)

    def on_typing_speed_changed(self):
        """Update typing speed label when the slider value changes."""
        typing_speed_wpm = self.typing_speed_slider.value()
        self.typing_speed_label.setText(f"Typing Speed: {typing_speed_wpm} WPM")
        self.settings['typing_speed_wpm'] = typing_speed_wpm

    def on_letter_by_letter_changed(self):
        """Update the letter-by-letter setting when the checkbox is toggled."""
        self.settings['letter_by_letter'] = self.letter_by_letter_checkbox.isChecked()

    def on_tts_rate_changed(self):
        """Update TTS rate label and settings when the slider value changes."""
        rate = self.tts_rate_slider.value()
        self.tts_rate_label.setText(f"TTS Rate: {rate}")
        self.settings['tts_rate'] = rate
        
    def on_play_tts_changed(self):
        """Show or hide TTS rate settings based on the 'Play TTS' checkbox."""
        play_tts_enabled = self.play_tts_checkbox.isChecked()
        self.tts_rate_slider.setVisible(play_tts_enabled)
        self.tts_rate_label.setVisible(play_tts_enabled)
        self.settings['play_tts'] = play_tts_enabled


    def revert_to_default_settings(self):
        """Revert all settings to default values."""
        self.settings = DEFAULT_SETTINGS.copy()
        self.temperature_slider.setValue(int(self.settings['temperature'] * 10))
        self.temperature_label.setText(f"Temperature: {self.settings['temperature']}")
        self.max_tokens_input.setText(str(self.settings['max_tokens']))
        self.auto_type_checkbox.setChecked(self.settings['auto_type'])
        self.letter_by_letter_checkbox.setChecked(self.settings['letter_by_letter'])
        self.typing_speed_slider.setValue(self.settings['typing_speed_wpm'])
        self.typing_speed_label.setText(f"Typing Speed: {self.settings['typing_speed_wpm']} WPM")
        self.play_tts_checkbox.setChecked(self.settings['play_tts'])
        self.tts_rate_slider.setValue(self.settings['tts_rate'])
        self.tts_rate_label.setText(f"TTS Rate: {self.settings['tts_rate']}")
        QMessageBox.information(self, "Info", "Settings reverted to default!")

    def save_additional_settings(self):
        """Save temperature, max_tokens, auto-type, letter by letter, typing speed, and TTS settings."""
        try:
            self.settings['max_tokens'] = int(self.max_tokens_input.text())
            self.settings['play_tts'] = self.play_tts_checkbox.isChecked()
            # TTS rate is already updated via on_tts_rate_changed
            save_settings(self.settings)
            QMessageBox.information(self, "Success", "Settings saved successfully!")
        except ValueError:
            QMessageBox.warning(self, "Error", "Max tokens must be an integer!")


    def save_custom_instructions(self):
        """Save the custom instructions entered by the user."""
        instructions = self.custom_instructions_text.toPlainText()
        save_custom_instructions(instructions)
        QMessageBox.information(self, "Success", "Custom instructions saved successfully!")
`,
    'backgroundai.py': `import keyboard
from openai import OpenAI
import os
import time
import threading
from PyQt5.QtWidgets import QApplication, QSystemTrayIcon, QMenu, QAction
from PyQt5.QtGui import QIcon
from menu import (SettingsWindow, load_or_create_api_key, load_or_create_keybinds,
                  load_selected_model, load_settings, load_custom_instructions)
import sys
import ctypes
from ctypes import wintypes
from win32com.client import Dispatch
import pythoncom

from queue import Queue, Empty


class SystemTrayIcon(QSystemTrayIcon):
    def __init__(self, app):
        super().__init__(app)
        script_directory = os.path.dirname(os.path.abspath(__file__))
        image_path = os.path.join(script_directory, "write.png")
        icon = QIcon(image_path) if os.path.exists(image_path) else app.style().standardIcon(QSystemTrayIcon.SP_ComputerIcon)
        self.setIcon(icon)
        self.setToolTip("OpenAI App")

        # Create the menu
        self.menu = QMenu()
        self.open_settings_action = QAction("Open Settings")
        self.open_settings_action.triggered.connect(open_menu)
        self.menu.addAction(self.open_settings_action)

        self.quit_action = QAction("Quit")
        self.quit_action.triggered.connect(app.quit)
        self.menu.addAction(self.quit_action)

        self.setContextMenu(self.menu)
        self.show()


# Default keybinds
DEFAULT_OPTIONS = {
    "prompt": "right shift",
    "completion": "right ctrl",
}

# Load or prompt for the API key (now using the function from PyQt5 menu)
api_key = load_or_create_api_key()

if not api_key:
    print("API key not found. Please set it in the settings.")
    #sys.exit(1)

# Initialize the OpenAI client with your API key
client = OpenAI(api_key=api_key)

# Event to control background task pause/resume
pause_event = threading.Event()

# Events to control stopping of typing and TTS
typing_stop_event = threading.Event()
tts_stop_event = threading.Event()

# Global variables to hold settings
keybinds = load_or_create_keybinds()
settings = load_settings()
custom_instructions = load_custom_instructions()

# Define constants for mutex
CREATE_MUTEX = 0x00000001
ERROR_ALREADY_EXISTS = 183


def check_single_instance():
    """Check if an instance of the program is already running."""
    mutex = ctypes.windll.kernel32.CreateMutexW(None, False, "Global\\AIKeyboardMutex")
    if ctypes.GetLastError() == ERROR_ALREADY_EXISTS:
        print("Another instance of the program is already running. Exiting.")
        sys.exit(0)  # Exit the program if another instance is found


def is_chat_model(model_id):
    """Determine if the model is a chat model or a legacy completion model."""
    # List of known chat models
    chat_models = [
        'gpt-3.5-turbo',
        'gpt-3.5-turbo-16k',
        'gpt-3.5-turbo-0125',
        'gpt-3.5-turbo-1106',
        'gpt-4',
        'gpt-4-0613',
        'gpt-4-1106-preview',
        'gpt-4-turbo',
        'gpt-4-turbo-2024-04-09',
        'gpt-4-turbo-preview',
        'gpt-4o',
        'gpt-4o-2024-05-13',
        'gpt-4o-mini',
        'gpt-4o-mini-2024-07-18',
        'gpt4o-0806-loco-vm',
    ]
    return model_id in chat_models


def wait_for_keypress():
    print(f"Press {keybinds['prompt']} or {keybinds['completion']} to start typing.")

    # Continuously wait for either the prompt or completion keybind
    while True:
        pause_event.wait()  # Wait if the event is paused
        event = keyboard.read_event()
        if event.event_type == keyboard.KEY_DOWN and event.name in [keybinds['prompt'], keybinds['completion']]:
            return event.name  # Return the key that was pressed to start the input capture


def capture_input():
    print("Started capturing text. Type now... (Press the same key to stop)")

    captured_text = []
    while True:
        pause_event.wait()  # Wait if the event is paused
        event = keyboard.read_event()
        if event.event_type == keyboard.KEY_DOWN:
            key = event.name

            # Stop capturing input when either keybind is pressed again
            if key in [keybinds['prompt'], keybinds['completion']]:
                break

            if key == 'backspace':
                if captured_text:
                    captured_text.pop()  # Remove last character on backspace
            elif key == 'space':
                captured_text.append(' ')  # Append space
            elif key == 'enter':
                captured_text.append('\n')  # Append newline on enter
            elif len(key) == 1:  # Only add single character keys
                captured_text.append(key)

    # Join the list of captured text into a single string
    captured_string = ''.join(captured_text)
    print("\nCaptured text:\n" + captured_string)

    return captured_string


def stream_openai_completion(prompt):
    try:
        # Load the selected model
        model_id = load_selected_model()
        # Load settings
        current_settings = load_settings()
        temperature = current_settings.get('temperature', 1.0)
        max_tokens = current_settings.get('max_tokens', 256)
        # Load custom instructions
        custom_instructions = load_custom_instructions()

        # Prepare the prompt or messages
        if is_chat_model(model_id):
            # Use the Chat Completion API
            messages = []
            if custom_instructions.strip():
                messages.append({"role": "system", "content": custom_instructions})
            messages.append({"role": "user", "content": prompt})

            response = client.chat.completions.create(
                model=model_id,
                messages=messages,
                stream=True,
                temperature=temperature,
                max_tokens=max_tokens,
                top_p=1,
                frequency_penalty=0,
                presence_penalty=0
            )
        else:
            # Use the Legacy Completion API
            # Combine custom instructions and prompt
            combined_prompt = f"{custom_instructions}\n{prompt}" if custom_instructions.strip() else prompt

            response = client.completions.create(
                model=model_id,
                prompt=combined_prompt,
                stream=True,
                temperature=temperature,
                max_tokens=max_tokens,
                top_p=1,
                frequency_penalty=0,
                presence_penalty=0
            )
        return response
    except Exception as e:
        print(f"Error: {str(e)}")
        return None


def clean_text(text):
    """Clean the text by removing newlines and non-printable characters."""
    # Remove newlines
    text = text.replace('\n', ' ').replace('\r', ' ')
    # Remove non-printable or unwanted characters
    text = ''.join(c for c in text if c.isprintable())
    return text.strip()


def type_out_text_fast_streamed(response):
    print("\nTyping out the text as it's received...")

    if response is None:
        return

    # Load settings
    current_settings = load_settings()
    auto_type = current_settings.get('auto_type', True)
    typing_speed_wpm = current_settings.get('typing_speed_wpm', 200)
    letter_by_letter = current_settings.get('letter_by_letter', True)
    play_tts = current_settings.get('play_tts', False)
    tts_rate = current_settings.get('tts_rate', 0)

    # Initialize queues and threads
    typing_queue = Queue()
    tts_queue = Queue()

    # Clear stop events
    typing_stop_event.clear()
    tts_stop_event.clear()

    if auto_type:
        typing_thread = threading.Thread(target=typing_worker, args=(typing_queue, typing_speed_wpm, letter_by_letter, typing_stop_event))
        typing_thread.daemon = True
        typing_thread.start()

    if play_tts:
        tts_thread = threading.Thread(target=tts_worker, args=(tts_queue, tts_rate, tts_stop_event))
        tts_thread.daemon = True
        tts_thread.start()

    # Start the stop listener
    stop_listener = threading.Thread(target=stop_listener_worker)
    stop_listener.daemon = True
    stop_listener.start()

    # Iterate over each streamed chunk as it comes in
    for chunk in response:
        pause_event.wait()  # Wait if the event is paused
        if typing_stop_event.is_set() or tts_stop_event.is_set():
            break  # Stop processing if stop event is set

        if hasattr(chunk, 'choices') and len(chunk.choices) > 0:
            choice = chunk.choices[0]
            token = None
            if hasattr(choice, 'delta') and hasattr(choice.delta, 'content'):
                # Chat completion response
                token = choice.delta.content
            elif hasattr(choice, 'text'):
                # Legacy completion response
                token = choice.text
            else:
                continue  # Skip if no content

            if token:
                # Put token into queues
                if auto_type:
                    typing_queue.put(token)
                if play_tts:
                    tts_queue.put(token)

    # Signal the workers to stop
    if auto_type:
        typing_queue.put(None)  # Sentinel value
        typing_thread.join()
    if play_tts:
        tts_queue.put(None)
        tts_thread.join()

    # Stop the stop listener
    keyboard.unhook_all()


def typing_worker(typing_queue, typing_speed_wpm, letter_by_letter, stop_event):
    # Calculate delay between characters based on typing speed (WPM)
    chars_per_minute = typing_speed_wpm * 5  # Approximate words per minute to characters per minute
    delay_per_char = 60 / chars_per_minute  # Time per character in seconds

    while True:
        if stop_event.is_set():
            break  # Exit the loop

        try:
            token = typing_queue.get(timeout=0.1)
        except Empty:
            continue

        if token is None:
            break  # Exit the loop

        if letter_by_letter:
            for char in token:
                if stop_event.is_set():
                    break  # Exit the loop
                keyboard.write(char)
                time.sleep(delay_per_char)
        else:
            keyboard.write(token)
            time.sleep(len(token) * delay_per_char)
        typing_queue.task_done()


def tts_worker(tts_queue, tts_rate, stop_event):
    pythoncom.CoInitialize()
    try:
        speaker = Dispatch("SAPI.SpVoice")
        SVSFlagsAsync = 1  # Manually define SVSFlagsAsync

        # Set the TTS rate
        speaker.Rate = tts_rate

        sentence_buffer = ""
        sentence_terminators = {'.', '!', '?'}

        while True:
            if stop_event.is_set():
                speaker.Speak("", 3)  # SVSFPurgeBeforeSpeak to stop speaking immediately
                break  # Exit the loop

            try:
                token = tts_queue.get(timeout=0.1)
            except Empty:
                continue  # Wait for more tokens

            if token is None:
                # Process any remaining text
                if sentence_buffer.strip():
                    clean_sentence = clean_text(sentence_buffer)
                    if clean_sentence:
                        speaker.Speak(clean_sentence, SVSFlagsAsync)
                        speaker.WaitUntilDone(-1)
                break  # Exit the loop
            else:
                # Accumulate tokens into sentences
                sentence_buffer += token

                # Process any complete sentences in the buffer
                while True:
                    # Find the earliest occurrence of a sentence terminator
                    indices = [sentence_buffer.find(t) for t in sentence_terminators if sentence_buffer.find(t) != -1]
                    if indices:
                        min_index = min(indices)
                        # Include the terminator
                        sentence_end = min_index + 1
                        sentence = sentence_buffer[:sentence_end]
                        # Clean and speak the sentence
                        clean_sentence = clean_text(sentence)
                        if clean_sentence:
                            speaker.Speak(clean_sentence, SVSFlagsAsync)
                            speaker.WaitUntilDone(-1)
                        # Remove the sentence from the buffer
                        sentence_buffer = sentence_buffer[sentence_end:]
                    else:
                        break  # No complete sentences left in the buffer

            tts_queue.task_done()
    finally:
        pythoncom.CoUninitialize()


def stop_listener_worker():
    def on_key_event(event):
        if event.event_type == 'down':
            # Set the stop events to stop typing and TTS
            typing_stop_event.set()
            tts_stop_event.set()
            # Unhook the listener
            keyboard.unhook_all()

    # Hook the keyboard to listen for any key press
    keyboard.hook(on_key_event)


def background_task():
    # Continuous loop to keep the program running indefinitely
    while True:
        pause_event.wait()  # Wait if the event is paused
        # Wait for prompt or completion keybind to start
        key_pressed = wait_for_keypress()

        # Capture the input from the user
        captured_text = capture_input()

        # Determine the prompt based on the key pressed
        if key_pressed == keybinds['prompt']:
            prompt = captured_text  # Use the captured text as is
        elif key_pressed == keybinds['completion']:
            prompt = f"Continue the following text: {captured_text}"

        # Send the captured text to OpenAI for streaming completion
        print("\nSending captured text to OpenAI for real-time completion...\n")
        response_stream = stream_openai_completion(prompt)

        # Type out the completion text fast as it's received
        type_out_text_fast_streamed(response_stream)


def on_quit(icon, item):
    icon.stop()
    # No need to call sys.exit() here; the main thread will exit after icon.stop()


def reload_settings():
    """Reload keybinds, settings, and custom instructions after settings are updated."""
    global keybinds, settings, custom_instructions
    keybinds = load_or_create_keybinds()
    settings = load_settings()
    custom_instructions = load_custom_instructions()
    print("Settings reloaded:", keybinds, settings)


def open_menu():
    """Function to open the PyQt5 menu and pause the background task."""
    pause_event.clear()  # Pause the background task
    window = SettingsWindow()
    window.exec_()  # This will block execution until the menu is closed
    reload_settings()  # Reload keybinds, settings, and custom instructions after the menu is closed
    pause_event.set()  # Resume the background task after the menu is closed


def setup_system_tray(app):
    # Provide the path to your icon image (e.g., "write.png")
    script_directory = os.path.dirname(os.path.abspath(__file__))
    image_path = os.path.join(script_directory, "write.png")
    icon = QIcon(image_path) if os.path.exists(image_path) else app.style().standardIcon(QSystemTrayIcon.SP_ComputerIcon)

    tray_icon = QSystemTrayIcon(icon, app)
    tray_icon.setToolTip("OpenAI App")

    # Create the menu
    menu = QMenu()

    open_settings_action = QAction("Open Settings")
    open_settings_action.triggered.connect(open_menu)
    menu.addAction(open_settings_action)

    quit_action = QAction("Quit")
    quit_action.triggered.connect(app.quit)
    menu.addAction(quit_action)

    tray_icon.setContextMenu(menu)
    tray_icon.show()



if __name__ == "__main__":
    # Ensure only one instance of the program is running
    check_single_instance()

    # Set the event to 'set' (background task can run)
    pause_event.set()

    # Initialize QApplication
    app = QApplication(sys.argv)

    # Run the background task in a separate thread
    task_thread = threading.Thread(target=background_task)
    task_thread.daemon = True
    task_thread.start()

    # Setup the system tray icon
    tray_icon = SystemTrayIcon(app)

    # Start the event loop
    sys.exit(app.exec_())
`,
    'write.png': 'images/write.png',
    'write.ico': 'images/write.png'
};

    
function showCode(filename) {
            const codeBlock = document.getElementById('code-block');
            const codeContainer = document.querySelector('.code-display');
            const isImage = /\.(png|jpg|jpeg|gif)$/i.test(filename);
    
            if (isImage) {
                codeBlock.innerHTML = '';
                codeContainer.style.backgroundColor = '#f0f0f0';
    
                const image = document.createElement('img');
                image.src = codeFiles[filename];
                image.alt = filename;
                image.style.maxWidth = '100%';
                image.style.borderRadius = '8px';
                image.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.1)';
                codeBlock.appendChild(image);
            } else {
                codeBlock.textContent = codeFiles[filename];
                codeContainer.style.backgroundColor = '#2d2d2d';
                Prism.highlightAll();
            }
            setActiveTab(filename);
        }
    
        function setActiveTab(activeFilename) {
            const buttons = document.getElementsByClassName('tab-button');
            for (let button of buttons) {
                button.classList.remove('active');
                if (button.textContent === activeFilename) {
                    button.classList.add('active');
                }
            }
        }
    
        function toggleFolder(folderId) {
            const folder = document.getElementById(folderId);
            folder.style.display = folder.style.display === "inline-flex" ? "none" : "inline-flex";
        }
    
        document.getElementById('copy-code-btn').addEventListener('click', function () {
            const code = document.getElementById('code-block').textContent;
            navigator.clipboard.writeText(code).then(function () {
                alert('Code copied to clipboard!');
            });
        });
    </script>
    <script>
        const codeHeader = document.querySelector('.code-header');
        let isDown = false;
        let startX;
        let scrollLeft;
    
        codeHeader.addEventListener('mousedown', (e) => {
            isDown = true;
            codeHeader.classList.add('active');
            startX = e.pageX - codeHeader.offsetLeft;
            scrollLeft = codeHeader.scrollLeft;
        });
    
        codeHeader.addEventListener('mouseleave', () => {
            isDown = false;
            codeHeader.classList.remove('active');
        });
    
        codeHeader.addEventListener('mouseup', () => {
            isDown = false;
            codeHeader.classList.remove('active');
        });
    
        codeHeader.addEventListener('mousemove', (e) => {
            if (!isDown) return; // stop the function from running
            e.preventDefault();
            const x = e.pageX - codeHeader.offsetLeft;
            const walk = (x - startX) * 3; //scroll-fast
            codeHeader.scrollLeft = scrollLeft - walk;
        });
    </script>
    
</body>
</html>
